<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Components on Technuflections</title>
    <link>http://brucou.github.io/tags/components/</link>
    <description>Recent content in Components on Technuflections</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 brucou</copyright>
    <lastBuildDate>Fri, 12 Jan 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://brucou.github.io/tags/components/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>cyclejs - coupling event handlers to view description, while keeping testability</title>
      <link>http://brucou.github.io/scratch/cyclejs---keeping-event-handlers-coupled-to-view-description-without-loosing-testability/</link>
      <pubDate>Fri, 12 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://brucou.github.io/scratch/cyclejs---keeping-event-handlers-coupled-to-view-description-without-loosing-testability/</guid>
      <description>Having event handlers declared together with the view  In sources, inject a subject factory In component, with that subject factory, create subject  subject will have automatically generatd unique id from the trace settings property  In view, with helper function, link the event listener to the subject in component, returns the subject when testing, send values through the subject  think some more I am close
 conclusion : whatever I do is the same as what I have, event@selector is necessary to test anyways.</description>
    </item>
    
    <item>
      <title>cyclejs and concurrency control - a study of architectural alternatives</title>
      <link>http://brucou.github.io/scratch/cyclejs----concurrency-control---a-study-of-architectural-alternatives/</link>
      <pubDate>Fri, 12 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://brucou.github.io/scratch/cyclejs----concurrency-control---a-study-of-architectural-alternatives/</guid>
      <description>concurrency control cf. Redux saga - all actions in one sink - several concurrent processes listening on actions - coordinated by ? shared-memory? message-passing? streams (declarative concurrncy)? investigate - https://redux-saga.js.org/, https://redux-saga.js.org/docs/recipes/, http://konkle.us/master-complex-redux-workflows-with-sagas/
cf. Concepts, Techniques, and Models of Computer Programming ou PROGRAMMATION Concepts, techniques et mod√®les for concurrency models</description>
    </item>
    
    <item>
      <title>Component models for user interfaces implementation - a comparison</title>
      <link>http://brucou.github.io/posts/component-models-for-user-interfaces-implementation---a-comparison/</link>
      <pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://brucou.github.io/posts/component-models-for-user-interfaces-implementation---a-comparison/</guid>
      <description>Abstract In the previous articles, we have presented our proposed component model for user interfaces implementation, which relies on a cyclejs architecture, and is based on streams and reactive programming techniques.
We will, in this article, compare our proposed component model to Angular2 and React component models1 along a few axes. The comparison will help us identify areas for future work : tooling, testing, and concurrency model.
Angular2 component model Description A component controls a patch of screen called a view.</description>
    </item>
    
    <item>
      <title>Applying componentization to reactive systems : sample application</title>
      <link>http://brucou.github.io/posts/applying-componentization-to-reactive-systems---sample-application/</link>
      <pubDate>Mon, 16 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://brucou.github.io/posts/applying-componentization-to-reactive-systems---sample-application/</guid>
      <description>Introduction As discussed in a former post, user interfaces are reactive systems, and can be specified through a reactive function which associate events (originating from the user, or the interfaced systems) to actions to be executed. Expressing events, actions, and local state as streams, and expressing local state update also as an action, we have : $actions = f(state, events)$, where $f$ is a pure function. In addition to that function, which expresses the logic of the application, interfaces with the relevant systems must be defined.</description>
    </item>
    
    <item>
      <title>A componentization model for cyclejs</title>
      <link>http://brucou.github.io/posts/a-componentization-framework-for-cyclejs/</link>
      <pubDate>Fri, 07 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>http://brucou.github.io/posts/a-componentization-framework-for-cyclejs/</guid>
      <description>Background A component framework or platform provides both a systematic method to construct components, possibly from other components (namely dealing with interfacing, binding and interactions between components), and a systematic interface between component and the component framework, by which components can be introspected, instantiated, executed, destroyed (namely dealing with component lifecycle)1.
The first figure shows a classification framework for software component models, emphasizing the miscellaneous responsibilities of a component model.</description>
    </item>
    
    <item>
      <title>Componentization against complexity</title>
      <link>http://brucou.github.io/posts/componentization-against-complexity/</link>
      <pubDate>Sat, 01 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>http://brucou.github.io/posts/componentization-against-complexity/</guid>
      <description>The power of abstraction We have previously seen that a reactive system can be described by equations involving a reactive function f such that actions = f(state, events). In theory, the function f is as complex as the specification of the reactive system to implement. In practice, it is often much more so, as dictated by the particular implementation choices made.
Complexity resists to a uniformally useful definition. However, it is generally accepted that there is a component of complexity which cannot be reduced by any particular technique.</description>
    </item>
    
  </channel>
</rss>